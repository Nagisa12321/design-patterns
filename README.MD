# Head First Designer Patterns

___

## 1. 策略模式(stategy)

- 策略模式定义了算法簇, 分别封装起来, 让它们之间可以相互替换。 此模式让算法的变化独立于使用法的客户

#### 🍺设计原则1:

- 找出应用中可能需要变化的地方, 把他们独立起来, 不要和那些不需要变化的代码混在一起

#### 🍺设计原则2:

- 针对接口编程, 而不是针对实现编程

#### 🍺设计原则3:

- 多用组合, 少用继承

#### ⭐'has a' is better than 'is a'

- "有一个"关系相当有趣, 每一只鸭子都有一个fly behavior 和 quack behavior 好将飞行和呱呱叫行为委托给他们处理

## 2. 观察者模式(observer)

- 观察者模式定义了对象之间一对多的依赖, 这样一来, 当一个对象改变状态 所有依赖都会收到通知, 自动更新

#### 🍺设计原则1:

- 为了交互对象之间的松耦合设计而努力

#### ⭐实现细节

1. 自己设计的`Observer/Subject`: 见[*weather*](src/main/java/com/jtchen/observer/weather)
2. 使用`java.util`中的`Observable/Observer`见[*weatherobservable*](src/main/java/com/jtchen/observer/weatherobservable)

#### ⭐ 关于`Observer::update(Observable o, Object arg)`

- `o`: 主题本身当作第一个变量, 好让观察者知道是哪个对象通知它的
- `arg`: 传入观察者的数据对象, 如果没有, 则为空

#### ⭐关于`Observable::notifyObservers()`

- 我用的是`notifyObservers(state)`(push), 把状态封装为一个State对象.
- 书中用的是`notifyObservers()`(pull)。然后观察者收到通知调用自己想要调用的getter方法

> 书中方法更胜一筹, 因为不用每次都传完整的内部信息给观察者, 会造成资源的浪费

#### ⭐关于`setChange()`

- `setChange()`方法用来标记已经改变的事实, 好让`notifyObservers()`知道它被调用 时应该通知观察者, 如果调用`notifyObservers()`之前, 没有调用`setChange()`, 观察者们将
  不会被通知
    - 另外还有`clearChanged()`和`hasChanged()`, 相关功能不再赘述。

#### ⭐不要依赖于观察者被通知的次序

- `Observable::notifyObservers()`中的通知次序是无序的。

#### ⭐`java.util.Obserable`的黑暗面

1. `Obserable`是一个类 你必须得继承他, 因此限制了复用的潜力。

2. `Obserable` 将关键的方法保护起来了, 比如`setChange()`。

#### ⭐ swing中也有相应的观察者模式"listener"

- 详见[swing](src/main/java/com/jtchen/observer/swing/SwingObserverExample.java)
- 主题: `button`, 观察者: 两个`Listener`对象, 通过add...Listener来注册
